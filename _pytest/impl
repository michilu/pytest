
Implementation plan for resources
------------------------------------------

1. Revert FuncargRequest to the old form, unmerge item/request
   (done)
2. make funcarg factories be discovered at collection time
3. Introduce funcarg marker
4. Introduce funcarg scope parameter
5. Introduce funcarg parametrize parameter
6. make setup functions be discovered at collection time
7. (Introduce a pytest_fixture_protocol/setup_funcargs hook)

methods and data structures
--------------------------------

A FuncarcManager holds all information about funcarg definitions
including parametrization and scope definitions.  It implements
a pytest_generate_tests hook which performs parametrization as appropriate.

as a simple example, let's consider a tree where a test function requires
a "abc" funcarg and its factory defines it as parametrized and scoped
for Modules.  When collections hits the function item, it creates
the metafunc object, and calls funcargdb.pytest_generate_tests(metafunc)
which looks up available funcarg factories and their scope and parametrization.
This information is equivalent to what can be provided today directly
at the function site and it should thus be relatively straight forward
to implement the additional way of defining parametrization/scoping.

conftest loading:
    each funcarg-factory will populate the session.funcargmanager

When a test item is collected, it grows a dictionary 
(funcargname2factorycalllist).  A factory lookup is performed 
for each required funcarg.  The resulting factory call is stored 
with the item.  If a function is parametrized multiple items are 
created with respective factory calls. Else if a factory is parametrized
multiple items and calls to the factory function are created as well.

At setup time, an item populates a funcargs mapping, mapping names
to values.  If a value is funcarg factories are queried for a given item
test functions and setup functions are put in a class
which looks up required funcarg factories.


