
.. _`unittest.TestCase`:

Support for unittest.TestCase / Integration of fixtures
=====================================================================

py.test has limited support for running Python `unittest.py style`_ tests.
It will automatically collect ``unittest.TestCase`` subclasses
and their ``test`` methods in test files.  It will invoke
``setUp/tearDown`` methods but also perform py.test's standard ways
of treating tests such as IO capturing::

    # content of test_unittest.py

    import unittest
    class MyTest(unittest.TestCase):
        def setUp(self):
            print ("hello") # output is captured
        def test_method(self):
            x = 1
            self.assertEquals(x, 3)
       
Running it yields::

    $ py.test test_unittest.py
    =========================== test session starts ============================
    platform linux2 -- Python 2.7.3 -- pytest-2.3.0.dev19
    collected 1 items
    
    test_unittest.py F
    
    ================================= FAILURES =================================
    ____________________________ MyTest.test_method ____________________________
    
    self = <test_unittest.MyTest testMethod=test_method>
    
        def test_method(self):
            x = 1
    >       self.assertEquals(x, 3)
    E       AssertionError: 1 != 3
    
    test_unittest.py:8: AssertionError
    ----------------------------- Captured stdout ------------------------------
    hello
    ========================= 1 failed in 0.01 seconds =========================

.. _`unittest.py style`: http://docs.python.org/library/unittest.html

Moreover, you can use pytest's new :ref:`autoactive fixtures` 
functions, thereby connecting pytest's :ref:`fixture mechanism <fixture>`
with a setup/teardown style::

    # content of test_unittest_funcargs.py
    import pytest
    import unittest

    class MyTest(unittest.TestCase):
        @pytest.fixture(autoactive=True)
        def chdir(self, tmpdir):
            tmpdir.chdir() # change to pytest-provided temporary directory
            tmpdir.join("samplefile.ini").write("# testdata")

        def test_method(self):
            s = open("samplefile.ini").read() 
            assert "testdata" in s

Running this file should give us one passed test because the setup
function took care to prepare a directory with some test data
which the unittest-testcase method can now use::

    $ py.test -q test_unittest_funcargs.py
    .

If you want to make a database attribute available on unittest.TestCases
instances, you can do it using :ref:`usefixtures` and a simple 
:ref:`fixture function`::

    # content of test_unittest_marked_db.py
    import pytest
    import unittest

    @pytest.fixture
    def db(request):
        class DummyDB:
            entries = []
        db = DummyDB()
        if request.instance is not None:
            request.instance.db = db
        return db

    @pytest.mark.usefixtures("db")
    class MyTest(unittest.TestCase):
        def test_append(self):
            self.db.entries.append(1)

        def test_method2(self):
            # check we have a fresh instance
            assert len(self.db.entries) == 0

Running it passes both tests::

    $ py.test -q test_unittest_marked_db.py
    ..

If you rather want to provide a class-cached "db" attribute, you 
can write a slightly different fixture using a ``scope`` parameter
for the fixture decorator ::

    # content of test_unittest_class_db.py
    import pytest
    import unittest

    @pytest.fixture(scope="class")
    def db_class(request):
        class DummyDB:
            entries = []
        db = DummyDB()
        if request.cls is not None:
            request.cls.db = db
        return db

    @pytest.mark.usefixtures("db_class")
    class MyTest(unittest.TestCase):
        def test_append(self):
            self.db.entries.append(1)

        def test_method2(self):
            # check we DONT have a fresh instance
            assert len(self.db.entries) == 1

Running it again passes both tests::

    $ py.test -q test_unittest_class_db.py
    ..
